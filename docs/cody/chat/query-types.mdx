# Query Types

<p className="subtitle">This page lists the all the query types that will return search results with the Sourcegraph omnibox.</p>

## Symbol Search

<p className="subtitle">Symbol Search is a query type or workflow that helps developers understand how specific symbols (like functions, variables, or hooks) are used across a codebase by combining search results with contextual analysis through chat.</p>

It enables developers to explore and understand symbol usage patterns through a two-step process. First, developers search for a specific symbol (like `useCallback`) using Sourcegraph Chat, which returns relevant code snippets from across the codebase. These search results are automatically preserved as context for follow-up chat interactions. Developers can then refine their understanding by selecting specific search results and asking natural language questions about the symbol's usage patterns. The chat will analyze the selected code context and provide a comprehensive summary of how the symbol is implemented and used throughout the codebase.

### Try it

1. Query for `= useCallback`
2. Select a subset of the search results which include usage for `useCallback`
3. Follow up and ask Sourcegraph chat `Summarize how useCallback is used`

### Demo

ðŸ”´ Waiting for UI to update ðŸ”´


## File Search

<p className="subtitle">File Search is a query type or workflow that enables users to locate specific files across repositories and perform targeted analysis on the selected files through natural language follow-up queries.</p>

File Search simplifies the process of finding and analyzing specific file types across your codebase. Unlike traditional code search, this workflow allows you to first identify relevant files (for example, all `package.json` files), select the specific files you want to analyze, and then ask follow-up questions about the selected files.

This two-step approach is particularly powerful when you need to analyze patterns or extract information from similar files spread across multiple repositories. For instance, you could identify all configuration files, select the ones from relevant services, and then analyze their contents for inconsistencies or gather specific information through natural language queries.

### Try it

1. Type `package.json`
2. Above the results, you will find the message "Query review selected a code search response."
3. Follow up with `List all the dependencies used across these package.json files`

### Demo

ðŸ”´ Draft, replace with final version and upload to GCP ðŸ”´

<video width="100%" controls>
  <source src="https://p21.p4.n0.cdn.zight.com/items/BlumxXBE/55c5afa3-dee3-4b6c-bfd9-d3802360db2f.mp4?v=ec57e9a8c8e4a3d3af88635fcaf796d7" type="video/mp4" />
</video>

## String Literal Search

<p className="subtitle">String literal search is a query type or workflow that allows you to find exact text matches by enclosing your search term in quotes, ensuring precise matching instead of keyword-based results.</p>

When you enclose text in quotes like `"// Scheme for Authorization header"` or `"unrecognized HTTP Authorization request"`, Sourcegraph performs an exact match search rather than keyword matching. After finding relevant files, you can select specific ones to analyze and ask follow-up questions about their contents - creating an interactive workflow that combines precise search with contextual code analysis.

ðŸ”´ Temp image ðŸ”´
![](https://p21.p4.n0.cdn.zight.com/items/8LuW5obg/895c40c8-82ff-4f42-ab21-c500ab3ce0d5.png?v=23fd39830504212ba80e2f51a31a0a4b)

### Try it out

1. Start a new chat with `"// Scheme for Authorization header"`
2. Select a subset of the search results which include usage for the string
3. Follow up with `Summarize the contents`

### Demo

ðŸ”´ Video coming soon ðŸ”´

## Error Lookups

<p className="subtitle">Error Lookups is a conversational workflow for the Sourcegraph omnibox that helps developers understand error messages by providing plain-English explanations of when and why specific errors occur in their codebase and external service calls.</p>

Developers can use Error Lookups to understand error messages occurring in their codebase. When encountering an error, especially from external services or dependencies, developers can use the omnibox to:

1. Search for specific error messages across their codebase
2. Select relevant files where the error is thrown or handled
3. Request a natural language explanation of the error's context, triggers, and implications

The workflow combines Sourcegraph's code search capabilities with AI-powered analysis to provide developers with clear, contextual understanding of error scenarios. Instead of having to dig through documentation or source code manually, developers can quickly grasp:

* The specific conditions that trigger the error
* The underlying reasons for the error occurrence
* Common scenarios where this error might appear
* Potential approaches to handling or preventing the error

This approach helps developers make more informed decisions about error handling and debugging, reducing the time spent deciphering cryptic error messages or searching through external documentation.

## Try it

* Query for `"unsupported value for type filter"`
* Select the file(s) where the error is thrown
* Follow up with "Explain when and why this error is thrown"

## Demo

ðŸ”´ Upload video to GCP ðŸ”´

<video width="100%" controls>
  <source src="https://p21.p4.n0.cdn.zight.com/items/QwuyA4q7/dda31e22-d3ba-4844-b1d5-95978f2a7b1f.mp4?v=75789259e408c85fa268aa105c974894" type="video/mp4" />
</video>
