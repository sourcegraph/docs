# Agentic Context Fetching

<p className="subtitle">
	{' '}
	Learn about agentic context fetching, a mini-agent that uses search and tools
	to retrieve context.
</p>

Cody's agentic context fetching experience can evaluate context and fetch any additional context (MCP, OpenCtx, terminal, etc.) by providing enhanced, context-aware chat capabilities. It extends Cody's functionality by proactively understanding your coding environment and gathering relevant information based on your requests before responding. These features help you get noticeably higher-quality responses.

This experience aims to reduce the learning curve associated with traditional coding assistants by minimizing users' need to provide context manually. It achieves this through agentic context retrieval, where the AI autonomously gathers and analyzes context before generating a response.

## Capabilities of agentic chat

The agentic context fetching experience leverages several key capabilities, including:

-   **Proactive context gathering**: Automatically gathers relevant context from your codebase, project structure, and current task
-   **Agentic context reflection**: Review the gathered context to ensure it is comprehensive and relevant to your query
-   **Iterative context improvement**: Performs multiple review loops to refine the context and ensure a thorough understanding
-   **Enhanced response accuracy**: Leverages comprehensive context to provide more accurate and relevant responses, reducing the risk of hallucinations

## What can agentic context fetching do?

Agentic context fetching can help you with the following:

### Tool Usage

It has access to a suite of tools for retrieving relevant context. These tools include:

-   **Code Search**: Performs code searches
-   **Codebase File**: Retrieves the full content from a file in your codebase
-   **Terminal**: Executes shell commands in your terminal
-   **Web Browser**: Searches the web for live context
-   **MCP**: (Configure MCP and add servers)[] to fetch external context
-   **OpenCtx**: Any OpenCtx providers could be used by the agent

It integrates seamlessly with external services, such as web content retrieval and issue tracking systems, using OpenCtx providers. To learn more, [read the OpenCtx docs](/cody/capabilities/openctx).

<Callout type="info">
	Terminal access is not supported on the Web. It currently only works with VS
	Code, JetBrains, and Visual Studio editor extensions.
</Callout>

## Terminal access

Agentic context fetching can use the CLI Tool to request the execution of shell commands to gather context from your terminal. Its ability to execute terminal commands enhances its context-gathering capabilities. However, it's essential to understand that any information accessible via your terminal could potentially be shared with the LLM. It's recommended not to request information that you don't want to share. Here's what you should consider:

-   **Requires user consent**: Agentic context fetching will pause and ask for permission each time before executing any shell command.
-   **Trusted workspaces only**: Commands can only be executed within trusted workspaces with a valid shell
-   **Potential data sharing**: Any terminal-accessible information may be shared with the LLM

Commands are generated by the agent/LLM based on your request. Avoid asking it to execute destructive commands.

## Use cases

Agentic context fetching can be helpful to assist you with a wide range of tasks, including:

-   **Improved response quality**: Helps you get better and more accurate responses than other LLMs, making up for the additional processing time for context gathering a non-issue
-   **Error resolution**: It can automatically identify error sources and suggest fixes by analyzing error logs
-   **Better unit tests**: Automatically includes imports and other missing contexts to generate better unit tests

## Enable agentic context fetching

Agentic context fetching is enabled by default. It uses LLM reflection and basic tool use steps to gather and refine context before sending it in the final model query. The review step in agentic context fetching experience defaults to Gemini 2.5 Flash and falls back to Claude Haiku or GPT 4.1 mini if Flash is unavailable.

You can disable agentic context in your extension settings using `cody.agenticContext`.

Terminal access for Enterprise users is disabled by default. To enable it, set the `agentic-chat-cli-tool-experimental` feature flag [terminal access](#terminal-commands).

## MCP support

Cody supports [Model Context Protocol (MCP)](https://modelcontextprotocol.io/introduction) for connecting to external context. MCP servers are utilized via Cody’s agentic context fetching. Users can configure multiple local MCP servers via their Cody extension settings. Based on your query, agentic context will determine which MCP tools to invoke and what parameters to provide to the tools. Cody will execute these tools and inject the context from the tool calls into the context window.

### Setting up MCP tools

MCP is disabled by default. To enable it, add the `agentic-context-mcp-enabled` feature flag to your Enterprise Sourcegraph instance.

Once MCP is enabled, there are two ways to configure an MCP server:

#### 1. From the editor extension UI

To configure an MCP server from the editor extension UI, click your profile icon in the Cody extension and select the **MCP Settings** option.

![mcp-via-ui](https://storage.googleapis.com/sourcegraph-assets/Docs/mcp-with-ui-2025.png)

Create a new server configuration and input the necessary arguments provided by the server. You can disable individual tools in the UI by clicking on them.

#### 2. From the editor extension settings

-   Edit your MCP configuration settings using the `cody.mcpServers` property in your extension settings.
    -   `settings.json` (VSCode)
    -   `cody_settings.json` (JetBrains)
-   Use the following format when adding a new server

<Callout type="tip">
	In JetBrains, you need the absolute path to the command. Use the `which`
	command in the terminal to find it. For example, `which npx`.
</Callout>

```json
"cody.mcpServers": {
    "<server_name>": {
      "command": "...",
      "args": [...],
      "env": {
	      ...
      },
      "disabledTools": [...]
    }
  }
```

When you submit a query, Cody will determine whether to use any of the server's tools.

![mcp-via-settings](https://storage.googleapis.com/sourcegraph-assets/Docs/mcp-via-settings.png)

### MCP Best Practices

Since MCP is an open protocol and servers can be created by anyone, your mileage may vary. Tool names, descriptions, and the underlying models you have available may all affect the performance of MCP retrieval. To get the best results using your MCP servers, we recommend the following:

-   Read through the tools of the servers you install and their parameters. Be as explicit as possible in your queries to provide all of the information the tool needs
-   If you don't get the desired results on the first try, iterate on your query. It may take a couple of tries to get the results you're expecting
-   Choose high-quality servers. Prefer servers from official sources over third parties. Read through the code to understand how the servers you are installing work

### Limitations

-   MCP is supported through Cody’s agentic context fetching capabilities. You must have these capabilities enabled in order to utilize MCP servers
-   Cody currently supports only local MCP servers
-   MCP offers three main capabilities: Tools, Resources, and Prompts. Currently, Cody supports only Tools
-   Since most MCP servers require users to create their access tokens, the servers will have the same access as whatever token you provide. For example, if a user has write permissions to Jira and creates an access token with write permissions, they can use Cody to write back into Jira via MCP. It is not possible today to limit write access across all MCP tools broadly. You should use tools with this consideration in mind
