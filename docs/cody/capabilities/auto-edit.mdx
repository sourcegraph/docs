# Auto-edit

<p className="subtitle">Auto-edit suggests code changes by analyzing your cursor movements and typing. After you've made at least one character edit in your codebase, it begins proposing contextual modifications based on your cursor position and recent changes.</p>

<Callout type="info">Auto-edit is currently in the Experimental stage for all Cody users. Enterprise users can also use this, but with limited support. If you have feedback or questions, please visit our [support forum](https://community.sourcegraph.com/).</Callout>

## Capabilities of auto-edit

- Can automatically insert and delete text

- Can modify code before and after the cursor position

- Can handle complex refactoring operations like adding parameters and unpacking functions

- Works with repetitive tasks, especially in test files

- Can propose similar changes across multiple locations based on recent edits

## Enabling auto-edit

Auto-edit is available exclusively for Pro and Enterprise users during the experimental release phase. Eligible Pro users will be gradually enrolled in the feature and will receive an in-editor notification when access is granted.

![Auto-edit demo](https://p21.p4.n0.cdn.zight.com/items/4guL2xzb/6d545dab-e2db-4114-a05e-c54b08e7f0bd.jpg?v=a3673b4b48aed41b1977858f18ba0369)

ðŸ”´ **Image to be uploaded to GCP** ðŸ”´

### Auto-edit access for Enterprise customers

**TBD -- waiting for Aravind to provide the details.**

## How does auto-edit work?

The system detects potential changes based on:

- Cursor placement in the code

- Recent changes made in similar contexts

- Function usage patterns

- Common refactoring patterns

## Auto-edit vs. Autocomplete

Autocomplete:

- Can only insert text, not delete

- Only proposes content after the cursor position

- Suggests on every character typed

Auto-edit:

- Can both insert and delete text

- Can modify code before and after the cursor position

- Proposes changes based on context and recent edits

- Can do everything autocomplete can do

## Auto-edit use cases

1. Function signature refactoring (adding error returns)

2. Updating function call sites after signature changes

3. Repetitive modifications in test files

4. Parameter additions and function unpacking

5. Type system updates across multiple locations

## Known limitations

- Requires at least one character edit in the codebase before suggestions become active
- May not propose all necessary changes in complex refactoring scenarios, requiring some manual edits
- Sometimes requires manual deletion or cleanup of code
- Suggestions may not cover all similar instances of code that could be changed
